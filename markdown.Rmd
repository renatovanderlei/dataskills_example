---
title: "Partial data analysis on some aspects of forest structure and species composition change along different  habitats in a dry forest facing slash-and-burn disturbance"
author: "Renato Vanderlei"
date: "2023-03-15"
output: 
  html_document:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{css, echo=FALSE}
pre {
  max-height: 300px;
  overflow-y: auto;
}

pre[class] {
  max-height: 100px;
}
```
```{css, echo=FALSE}
.scroll-100 {
  max-height: 100px;
  overflow-y: auto;
  background-color: inherit;
}
```

## Summary

In this document, I demonstrate how I am using R programming language to run some statistical analysis on the differences in some aspects of forest structure and tree taxonomic composition between different habitats following swidden agriculture.
I use a set of packages to import, organize, transform, calculate, and display the information I need to answer these two scientific questions.

Here, I am going to focus on 2 main questions:
1 - How do the total aboveground basal area, basal area of primary roots (i.e., belowground), and number of primary roots change among the different habitats?
2 - How does the taxonomic composition (i.e., set of species) change between habitats?

## Q1 - Importing and understanding the dataset

- First, let's import and visualize the data and named it "dados":
```{r import data, echo=FALSE}
#Defining the working directory:
setwd("D:/OneDrive/UoE/Courses/Data skills/DataSkills_RenatoVanderlei")
#importing data from a .csv file
dados <- read.table("q1_dataset.csv", header=T, sep=",", stringsAsFactors=T)
```
```{r visualize the data}
# We can see a dataset with 11 variables and 4588 observations. There are data observations at different levels of organization: individual trees (ind), plots (idade) and habitat (parcela).
str(dados)

```


- Let's organize the names of each habitats in a more understandable way. Call the dplyr package using library(dplyr).
```{r message=FALSE}
library(dplyr)

#Now, we use the function recode_factor to change the names of the categories:
dados$parcela<-recode_factor(dados$parcela,"f" = "Recently abandoned fields","r"="Regenerating stands", "o" = "Old-growth stands")
```

## Preparing the data to answer the first question
- To answer the question nº 1, we need to do two things: first, summarise the data of each individual tree and then aggregate the information at plot level.

So create a subset of the dataset focusing on the individuals data:

```{r subset_q1}
dados.ind <- subset(dados, !is.na(num_perf), select=c("parcela", "idade", "ind", "pre_piv"))
dados.ind <- subset(dados.ind, !is.na(pre_piv), select=c("parcela", "idade", "ind"))
str(dados.ind)
View(dados.ind)
```


- Let's calculate the basal area of each individual tree using their diameter information in the dados$das column, then the total basal are and, after that, merging the new column to the created subset:

```{r calculating ABTot}
# Using "with" function to call a column from the object and use its values
dados$AB <- with(dados, pi*(das/2)^2) 

#And using the function aggregate, we calculate the total basal by summing the basal area of each individual
ab.tot <- aggregate(AB ~ ind, data=dados, FUN=sum, na.rm=T)
names(ab.tot) <- c("ind", "ABtot")
str(ab.tot)

#merging the data created to the subset
dados.ind <- merge(dados.ind, ab.tot)
head(dados.ind)
```

Now, we are calculating the basal area of primary roots using the diameter of the primary roots (diam_pri) and total number of primary roots. We aggregate the number of primary roots (num_prim) in each individual tree (ind):
```{r calculating root data}
#Creating the basal area of primary roots column:
dados$AB_prim<-with(dados, pi*(diam_pri/2)^2)

#creating an object with the sum of the basal area of each individual:
ab.prim<-aggregate(AB_prim~ind, data=dados, FUN=sum, na.rm=T)

#renaming columns
names(ab.prim)<-c("ind", "AB_primary")

#checking
str(ab.prim)

#Now, the number of primary roots:
num.prim<-aggregate(num_prim~ind, data=dados, FUN=sum, na.rm=T)
names(num.prim)<-c("ind", "num_prim_roots")
str(num.prim)

#Then, let's merge the created columns to the subset
dados.ind <- merge(dados.ind, ab.prim)
dados.ind <- merge(dados.ind, num.prim)
str(dados.ind)
```
We have the data at individual level, but our samples are the plots!
So, let's create an object to aggregate the information at plot level:

```{r Creating dados.parcela}
ABtot.parc <- aggregate(ABtot ~ idade, data=dados.ind, FUN=sum)
names(ABtot.parc) <- c("idade", "ABtot")
View(ABtot.parc)

AB_primary_roots.parc <- aggregate(AB_primary ~ idade, data=dados.ind, FUN=sum)
names(AB_primary_roots.parc) <- c("idade", "AB_primary_roots")
View(AB_primary_roots.parc)

num_prim_roots.parc <- aggregate(num_prim_roots ~ idade, data=dados.ind, FUN=sum)
names(num_prim_roots.parc) <- c("idade", "n_prim_roots")
View(num_prim_roots.parc)

# And merging everything in a new object:
dados.parcela <- merge(ABtot.parc, AB_primary_roots.parc)
dados.parcela <- merge(dados.parcela, num_prim_roots.parc)

#defining the habitats:
dados.parcela$habitats <- substr(dados.parcela$idade, start=1, stop=1)
dados.parcela$habitats <- as.factor(dados.parcela$habitats)
dados.parcela$habitats<-recode_factor(dados.parcela$habitats,"f" = "Recently abandoned fields","r"="Regenerating stands", "o" = "Old-growth stands")

#And keep the order of regeneration status
dados.parcela$habitats<-ordered(dados.parcela$habitats, levels=c("Recently abandoned fields","Regenerating stands","Old-growth stands"))

View(dados.parcela) #Done!
```


Now, lets visualize the variables:

```{r Visualizing variables}
#Let's use the "hist" function to see the data distribution of the variables
par(mfrow=(c(1,3)))
hist(dados.parcela$ABtot)
hist(dados.parcela$AB_primary)
hist(dados.parcela$n_prim_roots)

#Some of them don't have a normal distribution (skewed to right)
#If we log-transform them, we can see that the distribution looks more like a bell-shape:
#Ps: number of primary roots is count data, so it is not advised to log-transform the data to use in models
#see O'hara and Kotze (2010) "Do not log-transform count data", https://doi.org/10.1111/j.2041-210X.2010.00021.x .
hist(log(dados.parcela$ABtot))
hist(log(dados.ind$AB_primary))

```


Then, let's run some models using the packages stats (glm function),  car (Anova function), multcomp (glht function)  rsq (rsq function), and ggplot2 to generate a nice plot:

```{r packages_models, message=FALSE}
#Call the lme4 package:
library(stats)
library(car)
library(multcomp)
library(rsq)
library(ggplot2)

```

## Models to answer the first question: 

1 - How the (a) total aboveground basal area, (b) basal area of primary roots (i.e., below ground) and (c) number of primary roots change among the different habitats?

### Question 1a
- (a) Our model is trying to find differences on the Aboveground biomass (ABtot) between the 3 habitats (habitats).

```{r model_AbTot}
model_abtot<-glm(log(ABtot)~habitats, data=dados.parcela) #Gaussian family is the default one for continuous data.

#We are going to use the shapiro.test function to analyze the normality of the residuals
shapiro.test(residuals(model_abtot))

#assess the results
Anova(model_abtot) #There are differences between the habitats, but let's check a pairwise comparison
abtot.tukey<-glht(model_abtot, mcp(habitats="Tukey"))
summary(abtot.tukey) #We can see differences between the recently abandoned fields and regenerating stands and also old-growth
rsq(model_abtot, adj=T) #r²adjusted (more precise) = 0.54

#Let's quickly visualize the data using a boxplot:
ab_tot<-ggplot(dados.parcela)+
  aes(x = habitats, y = ABtot) +
  geom_boxplot() +
  scale_fill_hue(direction = 1) +
  labs(x = "Habitats", y = "Total aboveground basal area (cm²/ha)") +
  theme_classic()+
  theme(axis.text=element_text(size=12),
        axis.title=element_text(size=14,face="bold"))
ab_tot
```

### Question 1b
- Now, let's check the (b) basal area of primary roots across the habitats

```{r model_ABRoots, class.output="scroll-100"}
model_abroots<-glm(AB_primary_roots~habitats, family=Gamma, data=dados.parcela) #Here, we used the Gamma family to better adjust our data distribution to the model

#We are going to use the shapiro.test function to analyze the normality of the residuals
shapiro.test(residuals(model_abroots))

#assess the results
Anova(model_abroots)

#There are differences between the habitats, but let's check a pairwise comparison
abroots.tukey<-glht(model_abroots, mcp(habitats="Tukey"))
summary(abroots.tukey) #We can see differences between the recently abandoned fields and regenerating stands 
rsq(model_abroots, adj=T) #r²adjusted (more precise) = 0.18

#Let's quickly visualize the data using a boxplot:
ab_prim_roots<-ggplot(dados.parcela)+
  aes(x = habitats, y = AB_primary_roots) +
  geom_boxplot() +
  scale_fill_hue(direction = 1) +
  labs(x = "Habitats", y = "Basal area of primary roots (cm²/ha)") +
  theme_classic()+
  theme(axis.text=element_text(size=12),
        axis.title=element_text(size=14,face="bold"))
ab_prim_roots
```

### Question 1c
- Finally, let's check (c) the differences on the number of primary roots (num_prim_roots) across the habitats (parcela). The number of primary roots is a count data, so we use the poisson family and need to check for the overdispersion of the data (performance package, check_overdispersion function).

```{r model_PrimRoots, message=FALSE}
library(performance)

model_primroots<-glm(n_prim_roots~habitats, family=poisson(link="log"), data=dados.parcela)
summary(model_primroots)

#Checking for overdispersion
check_overdispersion(model_primroots) #we have a high dispersion ratio

#In this case, we can change the function to use the negative binomial family (glm.nb) to better adjust our model
model_primroots<-glm.nb(n_prim_roots~habitats,link = "log", data=dados.parcela)
summary(model_primroots)
check_overdispersion(model_primroots) #our dispersion ration substantially reduced, but we can notice a huge outlier

#Visualize the plotted fitted valued vs residuals
par(mfrow=(c(2,2)))
plot(model_primroots)

#assess the results
Anova(model_primroots) #X²=10.93, df=2, p=0.004

#There are differences between the habitats, but let's check a pairwise comparison
nroots.tukey<-glht(model_primroots, mcp(habitats="Tukey"))
summary(nroots.tukey) #Recently abandoned fields have lower number of primary roots than the other 2 habitats 
rsq(model_primroots, adj=T) #r²adj=0.14

#Let's quickly visualize the data using a boxplot:
prim_roots<-ggplot(dados.parcela)+
  aes(x = habitats, y = n_prim_roots) +
  geom_boxplot() +
  scale_fill_hue(direction = 1) +
  labs(x = "Habitats", y = "Number of primary roots") +
  theme_classic()+
  theme(axis.text=element_text(size=12),
        axis.title=element_text(size=14, face="bold"))
prim_roots
```

Now, let's put together all the plots using the ggpubr package (ggarrange function):

```{r message=FALSE, fig.width=20,fig.height=5}
library("ggpubr")

plots<-ggarrange(ab_tot, ab_prim_roots, prim_roots, labels = c("a", "b", "c"),
                font.label = list(size = 5, color = "black", face = "bold", family = NULL),
                                ncol = 3, nrow = 1)

plots
```

As we can see, there are differences in all three variables across the habitats.
Recently abandoned fields have lower values than all other habitats.


## Question 2 - How the taxonomic composition (i.e., set of species) change between habitats?

We are going to calculate the ecological Jaccard index, which indicate the similarity of the plots according to their species' abundances and IDs. Then, we will perform and plot a Non-metric multidimensional scaling (NMDS) ordination to represent the compositions in 2 dimensions.

### Importing dataset for question 2
Here, we will import a dataset with the number of species in each plot. We used a pivot table to filter the suitable individuals, create the dataset, exclude some columns, insert the zeros and save as a csv in Excel:

```{r Import_Data_q2}
species<- read.table("species_dataset.csv", sep=",", header=TRUE)
species

#Let's keep the order of regeneration status
species$habitats<-ordered(species$habitats, levels=c("Recently abandoned fields","Regenerating stands","Old-growth stands"))
str(species) #75 species in all 28 plots
```

### Preparing object for the analysis

We need an object containing onl the plots compositions (i.e., species + abundances)
```{r filtering_sp}
filtered_species <- species[,3:76] #Remove the first 2 columns
filtered_species
```

Let's call the packages we need to calculate the Jaccard similarity index and NMDS
```{r message=FALSE}
library(BiodiversityR)
library(vegan)
```

### Calculating the Similarity index
Now, we calculate the Jaccard index using the betadiver function and "j" argument and then the mean value (varies from 0 - very different to 1 - equal species compositions)
```{r Calculating_Jaccard}
jaccard<-betadiver(filtered_species, "j")
mean(jaccard) #mean=0.06, very low similarity
```

### Running the NMDS and plotting the results

Now, let's run an NMDS using a distance matrix with the Jaccard distance, then plot the result and use the ordihull function to exihibit the limits of each habitat:
```{r nmds}
dist.jac <- vegdist(filtered_species, method = "jaccard", binary = F)
result <- metaMDS(dist.jac, k=2, trymax = 100)
result$stress #nmds stress should be below 2, so its ok.
plot(result, type="points")
ordihull(result, groups = species$habitats, show = "Recently abandoned fields", col="red")
ordihull(result, groups = species$habitats, show = "Regenerating stands", col="blue")
ordihull(result, groups = species$habitats, show = "Old-growth stands", col="green4")
legend("topleft", "stress = 0.08", bty = "n", cex = 1) # displays legend text of stress value 

```

In conclusion, the habitats have dissimilar species compositions (very low Jaccard index) and we can see how they share the species between them in the 2D plot.
